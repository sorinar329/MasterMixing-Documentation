\section{Implementation in PyCram}

\subsection{Robots Plan Execution}
The robots plan used for implementing the MixingActionDesignator and its evaluation is 
a simple plan, including the following steps:

\begin{itemize}
    \item Park Arms
    \item Elevate the robots torso
    \item Navigate to the tool used for mixing
    \item Pick up tool
    \item Park arms
    \item Move to kitchen counter
    \item Look at the container to mix the ingredients
    \item Mix ingredients
\end{itemize}

In the following subsections we will explain, how the robot uses its knowledge during task execution, 
to mix. 

\subsection{Asserted Knowledge}
Any robot capable of executing mixing motions need to have knowledge before executing a mixing task. 
The robot needs to know where the container and tools are located, for picking up and for navigation to Theoretically
respective places. It needs to know which ingredients have to be mixed, in simulation only their existence have to be known. 
It needs to know which task to execute, since we differentiate between different mixing tasks as discussed in this section. 


\subsection{Inferring Knowledge}
As of now, the robot doesn't know what kind of mixing motion it has to perform. Its associated parameters are also unknown. Therefore, the robot needs to reason about its assertional knowledge.
Once it has access to all relevant information, it can infer the appropriate mixing motion and the corresponding parameters through logical reasoning.
Logical reasoning is performed inside the custom resolver \textit{MixingActionSWRL}.

\subsection{MixingActionSWRL}
\textit{MixingActionSWRL} is a custom resolver using \textit{mixing} ontology to infer motions from the robots assertional knowledge.
The resolvers task is to fill the missing descriptions of which motion should be executed with its associated parameters.

\paragraph{Initialization}
The resolver loads the mixing ontology, initializes the task to execute and initializes all ingredients which are being mixed. 
All names need to be available for later instantiation.
The high level class \textit{Motion} is instantiated, representing the individual of all possible motions. 
The resolver attempts to reclassify this motion into a specific one that will be executed on the robot.

First container, tool and ingredients are instantiated, additionally a task instance is created and its relations with 
the other individuals are assigned. To find the proper corresponding class, to the names of the container, ingredients, task and tool
we perform fuzzy string matching to find a matching class to the name. 

\paragraph{Fuzzy String Matching}
Using the levenshtein distance, syntactic similarity of two different strings is computed. A low distance score
indicates a higher similarity than a high score. However, this metric does not account for semantic similarities, 
as the words meanings are not considered in the computation of distance.

\paragraph{Inference}
Once the relations have been assigned, using \textit{OWLReady} with builtin functions calling reasoners like \textit{Pellet} or \textit{HermIt},
reclassifies the motion instance using the defined \textit{SWRL} rules inside the \textit{mixing} ontology.
Since the individual instantiated from the class \textit{Motion} has been reclassified the motion parameters can be extracted from the class.

Finally, the resolver completes the missing description regarding the intended motion and its associated parameters and forwards it to the MixingAction.

\subsection{MixingAction}




